# -*- coding: utf-8 -*-
"""Brevium.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ht0Cegw7ca_QwAj3dLmpgk7ksusv_nLF
"""
import requests
from datetime import datetime, timedelta
import json

API_TOKEN = "40328a9c-1218-4206-9ecf-0c736be67092"

# This function will get the initial state of the schedule
def get_curr_schedule():
  response = requests.get(f"http://scheduling-interview-2021-265534043.us-west-2.elb.amazonaws.com/api/Scheduling/Schedule?token={API_TOKEN}")

  # Initialize map of appointments
  appointments = {}

  # If successful
  if response.status_code == 200:
    # Get the data
    data = response.json()
    # Loop through the apointments and map the time to the doctor and patient
    for appointment in data:
      doctorId = appointment['doctorId']
      personId = appointment['personId']
      time = appointment['appointmentTime']
      # If doctor already exists
      if doctorId in appointments:
        # If person already exists (has appointment w/ that doctor)
        if personId in appointments[doctorId]:
          appointments[doctorId][personId].append(time)
        
        # Initialize a list of appointment times
        else:
          appointments[doctorId][personId] = [time]
      # Initialize a list of appointment times
      else:
        appointments[doctorId] = {personId: [time]}
  # If call to API fails
  else:
    print(f"Request failed with status code: {response.status_code}")

  # Sort the apointments 
  for doctor, person in appointments.items():
    for person, appts in person.items():
      appointments[doctor][person] = sorted(appts)

  return appointments

# This function will do the actual scheuling and block of time slot
def appointmentScheduler(requestId, personId, preferredDays, preferredDocs, isNew, appointments):
  # Loop through the appointment time options given by person
  for date in preferredDays:
    # Validate the appointment
    if(valid_appointment_time(date, isNew)):
      if(valid_appointment(appointments, date, personId)):
        # Loop through patient's preferred doctor
        for doctor in preferredDocs:
          # Check if doctor is available
          if(doctor_is_available(doctor, date, appointments)):
            # create headers to send to API
            headers = {
                "doctorId": doctor,
                "personId": personId,
                "appointmentTime": date,
                "isNewPatientAppointment": isNew,
                "requestId": requestId
            }
            # Call the scheudling API and block of time slot of doctor with patient's appointment
            requests.post(f"http://scheduling-interview-2021-265534043.us-west-2.elb.amazonaws.com/api/Scheduling/Schedule?token={API_TOKEN}", data=headers)

# This function loops through all appointment requests made
def parse_appointment_requests(appointments):
  hasMoreRequests = True

  # Will run until there are no more requests left
  while hasMoreRequests:
    # Call the API that will send the new appointment in the request queue
    response = requests.get(f"http://scheduling-interview-2021-265534043.us-west-2.elb.amazonaws.com/api/Scheduling/AppointmentRequest?token={API_TOKEN}")
    # If the call is valid
    if response.status_code == 200:
      # Get the data 
      data = response.json()
      requestId = data['requestId']
      personId = data['personId']
      preferredDays = data['preferredDays']
      preferredDocs = data['preferredDocs']
      isNew = data['isNew']

      # Schedule the appointment for patient
      appointmentScheduler(requestId, personId, preferredDays, preferredDocs, isNew, appointments)

    # Set our boolean to false since there are no more requests left in the queue
    elif response.status_code == 204:
      hasMoreRequests = False

    # Any other status code will send an error
    else:
      print(f"Request failed with status code: {response.status_code}")

# Validate that the doctor doesn't already have an appointment at the given appointment time
def doctor_is_available(doctor, date, appointments):
  # Loop through all appointments that the doctor has and see if an appointment already exists at given time
  if doctor in appointments:
    for patient, appts in appointments[doctor].items():
      for time in appts:
        if(time == date):
          return False

  return True

# Validate the appointment time and date to make sure that the appointment could be made at that time
def valid_appointment_time(date, isNew):
  try:
    dt = datetime.strptime(date, '%Y-%m-%dT%H:%M:%S%z')

    # Check to make sure appointment between November and December of 2021
    if dt.year == 2021 and dt.month in (11, 12):
      # Check to make sure it is on a weekday
      if dt.weekday() < 5:
        # Check to make sure it is on the hour
        if dt.minute == 0 and dt.second == 0:
          # Check if the patient is a new patient
          if isNew:
            # Check to make sure appointment is either at 3 PM or 4 PM
            if 15 <= dt.hour <= 16:
              return True
          else:
            # Check to make sure appointment is between 8 AM and 4 PM
            if 8 <= dt.hour <= 16:
              return True
            
  except ValueError:
    pass

  return False

# Validate that the person has a week in between each of their appointments
def valid_appointment(appointments, date, person):
  appt = []
  isValid = False
  # For all the doctors, grab all appointments
  for doctor in appointments:
    if person in appointments[doctor]:
      appt.extend(appointments[doctor][person])

  # Loop through all appointments to make sure the new appointment is at least a week apart from all other existing appointments
  for dt in appt:
    if is_week_apart(dt, date):
      isValid = True
    return False

  return True

# Check to make sure appointments are at least 7 days apart
def is_week_apart(appointment1, appointment2):
    dt1 = datetime.strptime(appointment1, '%Y-%m-%dT%H:%M:%S%z')
    dt2 = datetime.strptime(appointment2, '%Y-%m-%dT%H:%M:%S%z')

    time_difference = dt2 - dt1

    return time_difference >= timedelta(days=7)

# Runs the scheuling service
def run_scheduling_service():
  # Runs the start API
  response = requests.post(f"http://scheduling-interview-2021-265534043.us-west-2.elb.amazonaws.com/api/Scheduling/Start?token={API_TOKEN}")
  if response.status_code == 200:

      # Get the inital schedule
      appts = get_curr_schedule()
      # Put in all the appointment requests on the schedule
      parse_appointment_requests(appts)

      print("Success")

  else:
      print(f"Request failed with status code: {response.status_code}")

# Run the testing/debugging API
def test_results():
  response = requests.post(f"http://scheduling-interview-2021-265534043.us-west-2.elb.amazonaws.com/api/Scheduling/Stop?token={API_TOKEN}")
  if response.status_code == 200:

      data = response.json()
      formatted_data = json.dumps(data, indent=4)
      print(formatted_data)


  else:
      print(f"Request failed with status code: {response.status_code}")


def main():
  # Run the start API and begin scheduling
  run_scheduling_service()

  # Run the stop and see how the schedule looks like after all appointment requests have been put in
  test_results()